import{_ as n,p as s,q as a,a1 as t}from"./framework-5866ffd3.js";const e="/assets/image-20240112104825058-d6a5b9b5.png",c="/assets/image-20240112105526118-f4953b76.png",p={},o=t(`<h1 id="static-assert" tabindex="-1"><a class="header-anchor" href="#static-assert" aria-hidden="true">#</a> _Static_assert</h1><p>_Static_assert()接受两个参数，如果第一个参数是<code>false</code>，则编译器显示第二个参数，并且编译失败。</p><h1 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h1><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// structs defined to match layout of hardware registers</span>
<span class="token keyword">typedef</span> <span class="token keyword">union</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        <span class="token keyword">union</span> <span class="token punctuation">{</span>
            <span class="token class-name">uint32_t</span> rbr<span class="token punctuation">;</span>   <span class="token comment">// receive buffer register</span>
            <span class="token class-name">uint32_t</span> thr<span class="token punctuation">;</span>   <span class="token comment">// transmit holding register</span>
            <span class="token class-name">uint32_t</span> dll<span class="token punctuation">;</span>   <span class="token comment">// divisor latch (LSB)</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">union</span> <span class="token punctuation">{</span>
            <span class="token class-name">uint32_t</span> dlh<span class="token punctuation">;</span>   <span class="token comment">// divisor latch (MSB)</span>
            <span class="token class-name">uint32_t</span> ier<span class="token punctuation">;</span>   <span class="token comment">// interrupt enable register</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">union</span> <span class="token punctuation">{</span>
            <span class="token class-name">uint32_t</span> iir<span class="token punctuation">;</span>   <span class="token comment">// interrupt identification register</span>
            <span class="token class-name">uint32_t</span> fcr<span class="token punctuation">;</span>   <span class="token comment">// FIFO control register</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">uint32_t</span> lcr<span class="token punctuation">;</span>       <span class="token comment">// line control register</span>
        <span class="token class-name">uint32_t</span> mcr<span class="token punctuation">;</span>       <span class="token comment">// modem control register</span>
        <span class="token class-name">uint32_t</span> lsr<span class="token punctuation">;</span>       <span class="token comment">// line status register</span>
        <span class="token class-name">uint32_t</span> reserved<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">uint32_t</span> usr<span class="token punctuation">;</span>       <span class="token comment">// busy status, at offset 0x7c</span>
        <span class="token class-name">uint32_t</span> reserved2<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">uint32_t</span> halt<span class="token punctuation">;</span>      <span class="token comment">// at offset 0xa4</span>
    <span class="token punctuation">}</span> regs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> padding<span class="token punctuation">[</span><span class="token number">0x400</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">uart_t</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UART_BASE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uart_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x02500000</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">_Static_assert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>UART_BASE<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>regs<span class="token punctuation">.</span>lcr<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0250000C</span><span class="token punctuation">,</span> <span class="token string">&quot;UART0 lcr reg must be at address 0x0250000C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">_Static_assert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>UART_BASE<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>regs<span class="token punctuation">.</span>dlh<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x02500404</span><span class="token punctuation">,</span> <span class="token string">&quot;UART1 dlh reg must be at address 0x02500404&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="为什么是0x02500000" tabindex="-1"><a class="header-anchor" href="#为什么是0x02500000" aria-hidden="true">#</a> 为什么是<code>0x02500000</code>？</h2><p>就是硬件地址，37MB地址的位置，d1-h_user_manual如下</p><p><img src="`+e+'" alt="image-20240112104825058"></p><h2 id="为什么硬件地址是共用体union类型" tabindex="-1"><a class="header-anchor" href="#为什么硬件地址是共用体union类型" aria-hidden="true">#</a> 为什么硬件地址是共用体<code>union</code>类型？</h2><p><code>union</code> 实现了让同一个地址当作不同的类型使用，所以uart_t 既可以看做是结构体 <code>regs</code> ，来控制串口寄存器，也可以看做<code>0x400 == 1KB</code>的占位，这样可以可以简单用uart_t[6]数组代表6个UART，</p><p><img src="'+c+'" alt="image-20240112105526118"></p><h2 id="static-assert-在这里的作用" tabindex="-1"><a class="header-anchor" href="#static-assert-在这里的作用" aria-hidden="true">#</a> _Static_assert 在这里的作用</h2><ul><li><code>#define UART_BASE ((uart_t *)0x02500000)</code>: <code>UART_BASE</code> 是一个指针，存储 <code>0x02500000</code>，类型是 <code>uart_t</code></li><li><code>UART_BASE[0]</code>: <code>0x02500000</code> 这个地址存储的值，union 类型，主要使用的是结构体<code>reg</code>代表的寄存器</li><li><code>UART_BASE[0].regs</code>: 使用struct类型的变量，通过改变<code>UART_BASE[0].regs</code>的值可以控制串口寄存器，或读取串口寄存器内容</li><li><code>&amp;(UART_BASE[0].regs.lcr)</code>: 读取<code>lcr</code>这个偏移量的地址</li><li><code>&amp;(UART_BASE[0].regs.lcr) == (uint32_t *)0x0250000C</code>: 判断 UART0的寄存器UART_LCR的地址是否是<code>0x0250000C</code></li><li><code>_Static_assert</code>: 硬件地址分配没有错，这此就能编译下去</li></ul><h2 id="没有意义" tabindex="-1"><a class="header-anchor" href="#没有意义" aria-hidden="true">#</a> 没有意义</h2><p>现在的知识无法理解为什么加_Static_assert的判断。因为以上代码的写法不会出现编译错误的情况。</p>',14),i=[o];function l(u,r){return s(),a("div",null,i)}const k=n(p,[["render",l],["__file","static-assert.html.vue"]]);export{k as default};
